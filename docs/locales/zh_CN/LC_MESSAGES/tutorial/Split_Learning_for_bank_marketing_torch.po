# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022 Ant Group Co., Ltd.
# This file is distributed under the same license as the SecretFlow package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: SecretFlow\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-31 18:47+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.13.0\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Language: zh_CN\n"
"X-Source-Language: C\n"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:9
msgid "Split Learning—Bank Marketing—Torch Backend"
msgstr "拆分学习：银行营销- Torch 后端"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:20
msgid ""
"The following codes are demos only. It’s **NOT for production** due to "
"system security concerns, please **DO NOT** use it directly in production."
msgstr "以下代码仅作为演示用，请勿直接在生产环境使用。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:31
msgid ""
"In this tutorial, we will use the bank’s marketing model as an example to "
"show how to accomplish split learning in vertical scenarios under the "
"SecretFlow framework using torch backend. SecretFlow provides a "
"user-friendly Api that makes it easy to apply your PyTorch model to split "
"learning scenarios to complete joint modeling tasks for vertical scenarios."
msgstr ""
"这个教程中，我们将以银行的市场营销模型为例，展示在隐语 SecretFlow 框架下如何完成垂直场景下的拆分学习。隐语 SecretFlow "
"框架提供了一套用户友好的 API ，可以很方便的将您的 PyTorch 模型应用到拆分学习场景，以完成垂直场景的联合建模任务."

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:33
msgid ""
"In this tutorial we will show you how to turn your existing ‘Torch’ model "
"into a split learning model under Secretflow."
msgstr "在接下来的教程中我们将演示如何将您已有的 Torch 模型变成隐语 SecretFlow 下的拆分学习模型。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:45
msgid "Task"
msgstr "任务"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:56
msgid ""
"Marketing is the banking industry in the ever-changing market environment, "
"to meet the needs of customers, to achieve business objectives of the "
"overall operation and sales activities. In the current environment of big "
"data, data analysis provides a more effective analysis means for the banking "
"industry. Customer demand analysis, understanding of target market trends "
"and more macro market strategies can provide the basis and direction."
msgstr ""
"市场营销是银行业在不断变化的市场环境中，为满足客户需要、实现经营目标的整体性经营和销售的活动。在目前大数据的环境下，数据分析为银行业提供了更有效的分析手段。对客户需求分析，了解目标市场趋势以及更宏观的市场策略都可以提供依据与方向。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:58
msgid ""
"The data from `kaggle "
"<https://www.kaggle.com/janiobachmann/bank-marketing-dataset>`__ is a set of "
"classic marketing data bank, is a Portuguese bank agency telephone direct "
"marketing activities, The target variable is whether the customer subscribes "
"to deposit product."
msgstr ""
"数据来自 `kaggle "
"<https://www.kaggle.com/janiobachmann/bank-marketing-dataset>`__ "
"上的经典银行营销数据集，是一家葡萄牙银行机构电话直销的活动，目标变量是客户是否订阅存款产品。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:70
msgid "Data"
msgstr "数据"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:72
msgid ""
"The total sample size was 11162, including 8929 training set and 2233 test "
"set."
msgstr "样本量总计11162个，其中训练集8929，测试集2233。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:73
msgid "Feature dim is 16, target is binary classification."
msgstr "特征16维，标签为2分类。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:74
msgid ""
"We have cut the data in advance. Alice holds the 4-dimensional basic "
"attribute features, Bob holds the 12-dimensional bank transaction features, "
"and only Alice holds the corresponding label."
msgstr ""
"我们预先对数据进行了切割， alice 持有其中的4维基础属性特征， bob 持有12维银行交易特征，对应的 label 只有 alice 方持有。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:85
msgid "Let’s start by looking at what our bank’s marketing data look like?"
msgstr "我们先来看看我们的银行市场营销数据长什么样的?"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:87
msgid ""
"The original data is divided into Bank Alice and Bank Bob, which stores in "
"Alice and Bob respectively. Here, CSV is the original data that has only "
"been separated without pre-processing, we will use ``secretflow preprocess`` "
"for FedData preprocess."
msgstr ""
"原始数据被拆分为 bank_alice 和 bank_bob ，分别存在 alice 和 bob 两方。这里的 csv "
"是仅经过拆分没有做预处理的原始数据，我们将使用隐语 SecretFlow 的 preprocess 进行 FedData 预处理。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:142
msgid "prepare data"
msgstr "数据准备"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:166
msgid ""
"We assume that Alice is a new bank, and they only have the basic information "
"of the user and purchased the label of financial products from other bank."
msgstr "我们假设 Alice 是一个新银行，他们只有用户的基本信息，和是否从其他银行购买过理财产品的 label 。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:382
msgid ""
"Bob is an old bank, they have the user’s account balance, house, loan, and "
"recent marketing feedback."
msgstr "Bob 端是一个老银行，他们有用户的账户余额，是否有房，是否有贷款，以及最近的营销反馈。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:737
msgid "Create Secretflow Environment"
msgstr "环境的搭建"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:748
msgid "Create 2 entities in the Secretflow environment [Alice, Bob]"
msgstr "环境的搭建"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:749
msgid "Where ‘Alice’ and ‘Bob’ are two ``PYU``."
msgstr "Alice 和 bob 是两个 PYU 。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:750
msgid ""
"Once you’ve constructed the two objects, you can happily start Splitting "
"Learning."
msgstr "一旦您构建了这两个对象，您可以愉快地开始拆分学习。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:762
msgid "Import Dependency"
msgstr "引入依赖"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:785
msgid "Prepare Data"
msgstr "准备数据"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:796
msgid "**Build Federated Table**"
msgstr "创建联邦表"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:798
msgid ""
"Federated table is a virtual concept that cross multiple parties, We define "
"``VDataFrame`` for vertical setting ."
msgstr "联邦表是一个跨多方的虚拟概念，我们定义 VDataFrame 用于垂直场景设置。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:800
msgid ""
"The data of all parties in a federated table is stored locally and is not "
"allowed to go out of the domain."
msgstr "联邦表中各方的数据存储在本地，不允许出域。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:802
msgid "No one has access to data store except the party that owns the data."
msgstr "除了拥有数据的一方之外，没有人可以访问数据存储。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:804
msgid ""
"Any operation performed on the federated table is scheduled by the driver to "
"each worker, and the execution instructions are delivered layer by layer "
"until the Python runtime of the specific worker. The framework ensures that "
"only the worker with ``worker.device`` equal to the ``Object.device`` can "
"operate on the data."
msgstr ""
"联邦表的任何操作都会由 driver 调度给每个 worker ，执行指令会逐层传递，直到特定 worker 的 Python "
"Runtime。框架确保只有当 worker 的 worker.device 和 Object.device 相同时，才能够操作数据。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:806
msgid ""
"Federated tables are designed for managing and manipulating multi-party data "
"from a central perspective."
msgstr "联邦表旨在从中心角度管理和操作多方数据。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:808
msgid ""
"Interfaces to ``Federated Tables`` are aligned to ``pandas.DataFrame`` to "
"reduce the cost of multi-party data operations."
msgstr "Federated Table 的接口与 pandas.DataFrame 对齐，以降低多方数据操作的成本。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:810
msgid ""
"The SecretFlow framework provides Plain&Ciphertext hybrid programming "
"capabilities. Vertical federated tables are built using ``SPU``, and "
"``MPC-PSI`` is used to safely get intersection and align data from all "
"parties."
msgstr ""
"隐语 SecretFlow 框架提供 Plain&Ciphertext （明密文）混合编程能力。垂直联邦表是使用 SPU 构建的， MPC-PSI "
"用于安全地获取来自各方的交集和对齐数据。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:812
msgid "|0c1d44f38e884c0e87885f2d587351b9|"
msgstr ""

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:814
msgid "vdataframe.png"
msgstr "vdataframe.png"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:826
msgid ""
"VDataFrame provides ``read_csv`` interface similar to pandas, the difference "
"is that ``secretflow.read_csv`` receives a dictionary that defines the path "
"of data for both parties. We can use ``secretflow.vertical.read_csv`` to "
"build the ``VDataFrame``."
msgstr ""
"VDataFrame 提供类似于 pandas 的 read_csv 接口，不同之处在于 secretflow.read_csv "
"接收一个定义双方数据路径的字典。我们可以使用 secretflow.vertical.read_csv 来构建 VDataFrame 。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:844
msgid "Create spu object"
msgstr "创建 SPU （密文运算单元）对象"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:881
msgid ""
"``data`` is a vertically federated table. It only has the ``Schema`` of all "
"the data globally."
msgstr "data 为构建好的垂直联邦表，它从全局上只拥有所有数据的 Schema 。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:892
msgid "Let’s examine the data management of ``VDF`` more closely."
msgstr "我们进一步来看一下 VDF 的数据管理。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:894
msgid ""
"As shown in the example, the ``age`` field belongs to ``Alice``, so the "
"corresponding column can be obtained from ``Alice``\\ ’s partition. However, "
"if ``Bob`` tries to obtain the ``age`` field, a ``KeyError`` error will be "
"reported."
msgstr ""
"通过一个实例可以看出， age 这个字段是属于 alice 的，所以在 alice 方的 partition 可以得到对应的列，但是 bob "
"方想要去获取 age 的时候会报 KeyError 错误。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:896
msgid ""
"We have a concept called Partition, which is a defined data fragment. Each "
"partition has its own device to which it belongs, and only the device to "
"which it belongs can operate on its data."
msgstr ""
"这里有一个 Partition 的概念，是我们定义的一个数据分片，每个 Partition 都会有自己的 device 归属，只有归属的 device "
"才可以操作数据。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:953
msgid "Next, we perform data preprocessing on the ``VDataFrame``."
msgstr "我们接着对生成的联邦表做数据预处理。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:954
msgid ""
"We use LabelEncoder and MinMaxScaler as examples. These two preprocessing "
"functions have corresponding concepts in SkLearn, and their usage methods "
"are similar to those in **sklearn**."
msgstr ""
"我们这里以 LabelEncoder 和 MinMaxScaler 为例，这两个预处理函数在 sklearn 中有对应的概念，它们的使用方法和 "
"sklearn 中是类似的。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1057
msgid "Standardize data via MinMaxScaler"
msgstr "通过 MinMaxScaler 做数据标准化"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1107
msgid ""
"Next we divide the data set into train-set and test-set, and change the "
"default dtype (float64) to float32 to be the same as model parameters."
msgstr "接着我们将数据集划分成训练集（train-set）和测试集（test-set）。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1169
msgid ""
"**Summary:** At this stage, we have finished defining ``federated tables``, "
"performing ``data preprocessing``, and partitioning the ``training set`` and "
"``test set``. The secretFlow framework defines a set of operations to be "
"built on the federated table (which is the logical counterpart of "
"``pandas.DataFrame``). The Secretflow framework defines a set of operations "
"to be built on the federated table (its logical counterpart is ``sklearn``) "
"Refer to our documentation and API introduction to learn more about other "
"features."
msgstr ""
"**小结** ：到这里为止，我们就完成了联邦表的定义，数据的预处理，以及训练集和测试集的划分。隐语 SecretFlow "
"框架定义了跨越多方的联邦表概念，同时定义了一套构建在联邦表上的操作（它在逻辑上对等 pandas.DataFrame） "
"，同时定义了对于联邦表的预处理操作（它在逻辑上对等 sklearn） ，您在使用过程中遇到问题，可以参考我们的文档以及 API "
"介绍，进一步了解其他的功能。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1182
msgid "Introduce Model"
msgstr "模型介绍"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1193
msgid ""
"**local version**: For this task, a simple DNN can be trained to take in "
"16-dimensional features, process them through a neural network, and output "
"the probability of positive and negative samples."
msgstr "**单机版本**：对于该任务一个基本的 DNN 就可以完成，输入16维特征，经过一个 DNN 网络，输出对于正负样本的概率。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1195
msgid "**Federate version**:"
msgstr "**联邦版本**："

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1197
msgid "Alice:"
msgstr "Alice ："

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1199
msgid ""
"base_net: Input 4-dimensional feature and go through a DNN network to get "
"hidden."
msgstr "base_net ：输入4维特征，经过一个 DNN 网络得到 hidden 。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1201
msgid ""
"fuse_net: Receive hidden features calculated by Alice and Bob, input them to "
"fusenet for feature fusion, and complete the forward process and backward "
"process."
msgstr ""
"fuse_net ：接收 Alice 以及 Bob 计算得到的 hidden 特征，输入这些特征到 fuse_net "
"，进行特征融合，送入之后的网络完成整个前向传播过程和反向传播过程。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1203
msgid "Bob:"
msgstr "Bob ："

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1205
msgid ""
"base_net: Input 12-dimensional features, get hidden through a DNN network, "
"and then send hidden to Alice to complete the following operation."
msgstr ""
"base_net ：输入12维特征，经过一个 DNN 网络得到 hidden ，然后将 hidden 发送给 Alice 方，完成接下来的运算。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1217
msgid "Define Model"
msgstr "定义模型"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1228
msgid "Next, we will start creating the Split model."
msgstr "接下来，我们将开始创建拆分模型。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1230
msgid ""
"We have defined the SLModel, which is used to build split learning for "
"vertically partitioned data. We have also defined a simple and easy-to-use "
"extensible interface TorchModel, allowing you to easily transform your "
"existing model to perform vertically partitioned federated modeling."
msgstr ""
"我们已经定义了 SLModel 用于构建垂直场景的拆分学习。我们也定义了简单易用的可扩展接口 TorchModel "
"，可以很方便的将您已有的模型转换进而进行垂直场景联邦建模。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1241
msgid ""
"Split learning is to break up a model so that one part is executed locally "
"on the data and the other part is executed on the label side. First let’s "
"define the locally executed model – base_model."
msgstr ""
"拆分学习即将一个模型拆分开来，一部分放在数据的本地执行，另外一部分放在有 label 的一方。首先我们来定义本地执行的模型—— base_model 。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1369
msgid ""
"Next we define the side with the label, or the server-side model – "
"fuse_model. Only the fuse_model need to define metrics."
msgstr ""
"接下来我们定义有 label 的一方，或者 server 端的模型—— fuse_model 。只有 fuse_model 需要定义 metrics 。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1465
msgid "Create Split Learning Model"
msgstr "创建拆分学习模型"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1467
msgid "Secretflow provides the split learning model ``SLModel``."
msgstr "隐语 SecretFlow 提供了拆分学习模型 SLModel 。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1468
msgid "To initial SLModel only need 3 parameters."
msgstr "我们需要三个参数来初始化 SLModel 。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1470
msgid ""
"base_model_dict: A dictionary needs to be passed in all clients "
"participating in the training along with base_model mappings"
msgstr "base_model_dict ：一个字典，它需要传入参与训练的所有 client 以及 base_model 映射"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1471
msgid "device_y: PYU, which device has label"
msgstr "device_y ： PYU 对象，哪一方持有 label"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1472
msgid "model_fuse: The fusion model"
msgstr "model_fuse ：融合模型，具体的优化器以及损失函数都在这个模型中进行定义"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1483
msgid "Define base_model_dict."
msgstr "定义 base_model_dict 。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:1980
msgid "Let’s visualize the training process"
msgstr "我们来可视化训练过程"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:2127
msgid "Compare to local model"
msgstr "和单方模型的对比"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:2141
msgid ""
"Here, we use the same model structure as the one used in the split learning "
"example, but only the model structure for Alice is used in this case. The "
"code for defining the model is shown below."
msgstr "在这里，我们使用与分裂学习示例中相同的模型结构，但仅在这种情况下使用 Alice 的模型结构。定义模型的代码如下所示。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:2142
msgid "#### Data"
msgstr "数据"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:2143
msgid ""
"The data also use kaggle’s anti-fraud data. Here, we just use Alice’s data "
"of the new bank."
msgstr "数据也是使用 Kaggle 的反欺诈数据集。在这里，我们只使用 Alice 的新银行数据。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:2144
msgid ""
"1. The total sample size was 11162, including 8929 training set and 2233 "
"test set."
msgstr "1. 样本量总计11162个，其中训练集8929， 测试集2233。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:2145
msgid "2. The feature dimension is 4."
msgstr "2. 特征维度为4。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:2190
msgid "Data process"
msgstr "数据处理"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:2393
msgid "Conclusion"
msgstr "结论"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:2404
msgid ""
"This tutorial introduces what is split learning and how to do it in "
"secretFlow."
msgstr "这篇教程介绍了什么是拆分学习以及如何在隐语 SecretFlow 中实现拆分学习。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:2405
msgid ""
"It can be seen from the experimental data that split learning has "
"significant advantages in expanding sample dimension and improving model "
"effect through joint multi-party training."
msgstr "从实验数据可以看出，拆分学习在扩充样本维度，通过联合多方训练提升模型效果方面有显著优势。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:2406
msgid ""
"This tutorial uses plaintext aggregation to demonstrate, without considering "
"the leakage problem of hidden layer. Secretflow provides AggLayer to avoid "
"the leakage problem of hidden layer plaintext transmission through "
"MPC,TEE,HE, and DP. If you are interested, please refer to relevant "
"documents."
msgstr ""
"本教程使用明文聚合来做演示，同时没有考虑隐藏层的泄露问题，隐语 SecretFlow 提供了聚合层 AggLayer ，通过 MPC , TEE , "
"HE ，以及 DP 等方式规避隐层明文传输泄露的问题。如果您感兴趣，可以看相关文档。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:2407
msgid ""
"Next, you may want to try different data sets, you need to vertically shard "
"the data first and then follow the flow of this tutorial."
msgstr "下一步，您可能想尝试不同的数据集，您需要先将数据集进行垂直切分，然后按照本教程的流程进行。"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:2419
msgid "Acknowledgement"
msgstr "致谢"

#: ../../tutorial/Split_Learning_for_bank_marketing_torch.ipynb:2421
msgid ""
"This work is finished by @dongdongzhaoUP with the help of @zhangxingmeng ."
msgstr "本文由 @dongdongzhaoUP 在 @zhangxingmeng 指导下完成。"

#~ msgid "What is Split Learning？"
#~ msgstr ""

#~ msgid ""
#~ "The core idea of split learning is to split the network structure. Each "
#~ "device (silo) retains only a part of the network structure, and the "
#~ "sub-network structure of all devices is combined together to form a "
#~ "complete network model. In the training process, different devices "
#~ "(silos) only perform forward or reverse calculation on the local network "
#~ "structure, and transfer the calculation results to the next device. "
#~ "Multiple devices complete the training through joint model until "
#~ "convergence."
#~ msgstr ""

#~ msgid "|dcce4c2e6b054184846a36d4adde3643|"
#~ msgstr ""

#~ msgid "split_learning_tutorial.png"
#~ msgstr ""

#~ msgid "**Alice**\\ ：have *data_alice*\\ ，\\ *model_base_alice*"
#~ msgstr ""

#~ msgid "**Bob**: have *data_bob*\\ ，\\ *model_base_bob*\\ ，\\ *model_fuse*"
#~ msgstr ""

#~ msgid ""
#~ "**Alice** uses its data to get *hidden0* through *model_base_Alice* and "
#~ "send it to Bob."
#~ msgstr ""

#~ msgid "**Bob** gets *hidden1* with its data through *model_base_bob*."
#~ msgstr ""

#~ msgid ""
#~ "*hidden_0* and *hidden_1* are input to the *AggLayer* for aggregation, "
#~ "and the aggregated *hidden_merge* is the output."
#~ msgstr ""

#~ msgid ""
#~ "**Bob** input *hidden_merge* to *model_fuse*, get the gradient with "
#~ "*label* and send it back."
#~ msgstr ""

#~ msgid ""
#~ "The gradient is split into two parts *g_0*, *g_1* through *AggLayer*, "
#~ "which are sent to **Alice** and **Bob** respectively."
#~ msgstr ""

#~ msgid ""
#~ "Then **Alice** and **Bob** update their local base net with *g_0* or "
#~ "*g_1*."
#~ msgstr ""

#~ msgid "|b5f2147caff54844b58c1413ecbddd2a|"
#~ msgstr ""
