Design of Component Specification
=================================

Component Specification could be splitted into two parts: Core protocols including Data, Component and Node Evaluation Protocol and Ancillary protocols 
including SecretFlow Cluster Configurations and SecretFlow Data. Core protocols apply to all applications integrated to 
SecretFlow Ecosystem while Ancillary protocols are only for SecretFlow.

Component Specification takes some assumptions from our point of view. Please read this document before 
checking :doc:`/component/comp_spec`.

.. note:: At this moment, we don't have an official protocol for Pipelines and Scheduling.


Data
----

Defined in data.proto.

SystemInfo
^^^^^^^^^^
For input data, **SystemInfo** describes the application and environment which could consume the data.
For output data, it bears such information.


DataRef
^^^^^^^

A **DataRef** is a pointer to a single file belongs to one party. **uri** is the relative path to storage root of its owner.
**DataRef** is public and open to all parties. Don't try to store any secret with uris. You need to protect the files pointed by uris instead.


DistData
^^^^^^^^

We call all the data consumed and generated by components as **DistData**, aka Distributed Data, which means it is consists multiple parts owned by
different parties. 

Don't confused with data partitioning in Database systems. In such systems, dividing a large dataset into several small partitions placed on different machines is quite
common. However, there are no owner enforcements on partitions, which means which machine is selected to place a partition is random.

In a privacy-preserving system, some models and tables are splitted and partitions are owned by different parties. One partition of **DistData** is called **DataRef**.

For simplicity, all data are DistDatas even it only consists one partition (even none at all).

Besides **DataRef**, **DistData** also contains **meta** to store any extra public information for different types of **DistData**. 
We also proposed some common types of **DistData** including Vertical tables and Individual tables.

**DistData** is public and open to all parties, again don't store any secret with **DistData**.


Component
---------

Defined in comp.proto.

AttributeDef
^^^^^^^^^^^^

We organize all attributes of a component as attribute trees. The leaves of the tree are called **Atomic Attributes**,
which represent solid fields for users to fill-in e.g. bucket size or learning rate. The non-leaf nodes of
the tree are called **Attribute Group**. There are two kind of Attribute Groups:

* Struct Group: all children of the group need to fill-in together.
* Union Group: select one child of the group to fill-in.

The child of an Attribute Group could be another Attribute Group.

A **AttributeDef** represents a node of a component attribute tree. 

.. note::

    **Attribute Groups** are advanced usage in Component Attribute declaration. Only a small part of audiences may utilize
    this feature one day. You may check **Attribute Groups** when you need to organize groups of attributes.

For **Atomic Attributes**, you should check **AtomicAttrDesc** to specify the types of attributes, default_value, allowed_values, ranges, etc.

For **Union Group**, you should use **UnionAttrGroupDesc** to specify the default selection of children.

If you are going to build a attribute tree, you may use **prefixes** to indicate the parent of the attribute tree node.


IoDef
^^^^^

IoDef is to specify the requirement of an input or output of the component. You should use **types** to declare accepted types
of **DistData**. 

For table **DistDatas**, we found many SecretFlow applications would require users to select columns and fill-in extra attributes for each selected
columns, this is satisfied by **TableAttrDef**.

.. note::
    Again, you could leave **TableAttrDef** alone at this moment since it is unusual to use.



ComponentDef
^^^^^^^^^^^^

You could use ComponentDef to define a component:

- domain: namespace of component.
- name: should be unique among the domain.
- version: component version is separate from component list version.
- attrs, inputs and outputs.

Only a tuple of domain, name and version could locate a component.

CompListDef
^^^^^^^^^^^

A group of a components could be organized by a **CompListDef**.
SecretFlow Component List is an instance of a CompListDef.



SecretFlow Cluster
------------------

Defined in cluster.proto.

.. note::
    SecretFlow Cluster protos are not application to other privacy-preserving applications.


SFClusterDesc
^^^^^^^^^^^^^

SFClusterDesc stores intrinsic properties of a SecretFlow cluster, including:

- SecretFlow version
- Python version
- parties participated in computation
- Security configs of secret devices like protocol of SPU devices.

The reason we regard SFClusterDesc as intrinsic properties is because SFClusterDesc is important to data security and integrity.
For example, a DistData generated by one cluster could only consumed by another cluster only 
if their SFClusterDesc are compatible.

SFClusterDesc is part of **SystemInfo**.


StorageConfig
^^^^^^^^^^^^^

**StorageConfig** specifies the storage root of a party. It could be a local file path,
a database table or an OSS bucket.


SFClusterConfig
^^^^^^^^^^^^^^^

A SFClusterConfig contains all information to setup a SecretFlow cluster, besides **SFClusterDesc**, it contains
public configs and private configs.

**PublicConfig** should be revealed to all parties, including:

- Addresses for RayFed. Parties need this information to communicate to each other.
- Addresses for SPU devices. SPU Runtimes of all parties need to this information to connect.

**PrivateConfig** is unique to each party, including:

- self_party: who am I?
- ray_head_addr: The address of Ray cluster.
- storage_config: storage root of the party.

.. note::
    You may be surprised at storage_config is private since it seems fine to be public.
    Well, SFClusterConfig is the minimum set of configs to start a SecretFlow cluster, so we just make storage_config private since it is unnecessary to broadcast everyone's storage root.


SecretFlow Data Types
---------------------

Based on **DistData**, we also proposed some common types for SecretFlow applications.

**IndividualTable**, **VerticalTable** and **DeviceObjectCollection** are defined in data.proto.
**Report** is defined in report.proto.


IndividualTable
^^^^^^^^^^^^^^^

**IndividualTable** is a table owned by one party, which means there is a single item in data_refs field of DistData.
**IndividualTable** should be packed into **meta** field of DistData which includes **schema** and **num_lines**.


VerticalTable
^^^^^^^^^^^^^

**VerticalTable** is a vertical partitioned table owned by multiple parties. **VerticalTable** contains multiple **schema**.
Correspondingly, there should be multiple data_refs in DistData.


DeviceObjectCollection
^^^^^^^^^^^^^^^^^^^^^^

We use **DeviceObjectCollection** to an MPC models. We would provide more details for this part later.


Report
^^^^^^

Report is a special DistData which is totally public and doesn't own any data_ref.
We use a **Report** to reveal statistic outputs in most cases.

Report related protos are:

- Descriptions: Displays multiple read-only fields in groups.
- Table: Displays rows of data.
- Div: A division or a section of a page, consists of Descriptions, Tables or Divs.
- Tab: A page of a report, consists of Divs.
- Report: The top-level of a report, consists of Tabs.


Node Evalution
--------------

A runtime instance of a component is called a Node. We use **NodeEvalParam** to
fill-in all required attributes and inputs and get outputs in **NodeEvalResult** from node.

NodeEvalParam
^^^^^^^^^^^^^

It contains:

- domain, name, version: To locate a component.
- attr_paths, attrs: Attributes of the component.
- inputs: Inputs of the component, should be DistDatas.
- output_uris: Output uris for each output.

.. note:: 
    **Why only one uri for each output?** For each output, only one uri is provided. It will be used by
    all parties to generate all data_refs of this output DistData. It looks weird since we may give each party
    a different uri. However, this is not a good idea:
    
    - When we have multiple parties, the list of output uris would be extremely long.
    - Each party has the full control of the storage root and they could move the files afterwards. We hope to keep our system simple and don't invest any effort in file system management.

NodeEvalResult
^^^^^^^^^^^^^^

It contains output DistDatas.
